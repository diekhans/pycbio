#!/usr/bin/env python
# Copyright 2006-2010 Mark Diekhans

# FIXME: Required biopython with bug #1758 fixed (genbank parser chokes on /transl_except)

import sys, os, traceback
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.insert(0, myBinDir + "/../lib")

from Bio.GenBank import Iterator, RecordParser
from optparse import OptionParser
from pycbio.sys import fileOps, setOps, typeOps
from pycbio.sys.Enumeration import Enumeration
from pycbio.sys.fileOps import prLine
from pycbio.tsv.TSVReader import TSVReader
from pycbio.hgdata.GenePred import GenePred,CdsStat
from pycbio.ncbi.Gbff import *

# FIXME: too many special cases in code, simplify.

GeneType = Enumeration("GeneType",
                       ("unknown", "protGene", "rnaGene", "immunoglobulin", "other"),
                       bitSetValues=True)
ActiveType = Enumeration("ActiveType",
                         ("unknown", "live", "pseudo"),
                         bitSetValues=True)

class CmdOpts(object):
    usage = """%prog [options] gbff genePred

Parse gene features from genbank flat file records and create a genePred.
Will do pseudogenes or non-pseudogenes.  This is designed to be used on the
NCBI *.gbs.gz files to extract chromosome annotations.  Will read compressed
files.

Retrieve files with:
    wget -nv -r -A 'hs_ref_*.gbs.gz' 'ftp://ftp.ncbi.nih.gov/genomes/H_sapiens/CHR*'

To obtain correct association of CDS to mRNA, use the rna.q file:
   ftp://ftp.ncbi.nih.gov/genomes/H_sapiens/mapview/rna.q.gz
otherwise, associated are chosen by best match
"""
    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        parser.add_option("--rnaq", dest="rnaq", action="store", default=None,
                          help="use this rna.q file to match CDS to mRNA")
        parser.add_option("--protGenes", dest="protGenes", action="store_true",
                          default=False,
                          help="extract protein coding gene annotations, default if no other get options are specified")
        parser.add_option("--rnaGenes", dest="rnaGenes", action="store_true",
                          default=False,
                          help="extract non-protein coding gene annotations")
        parser.add_option("--otherGenes", dest="otherGenes", action="store_true",
                          default=False,
                          help="extract gene annotations where type is undetermined")
        parser.add_option("--immunoglobulins", dest="immunoglobulins", action="store_true",
                          default=False,
                          help="get immunoglobulins genes")
        parser.add_option("--allGenes", dest="allGenes", action="store_true",
                          default=False,
                          help="extra all genes, and immunoglobulins, both pseudo and live")
        parser.add_option("--pseudo", dest="pseudo", action="store_true",
                          default=False,
                          help="extract  pseudogenes, either immunoglobulin or assumed protein coding (since type not annotated)")
        parser.add_option("--live", dest="live", action="store_true",
                          default=False,
                          help="extract  live gene annotations; default if --pseudo is not specified")
        parser.add_option("--ext", dest="ext", action="store_true", default=False,
                          help="make extended genePreds")
        parser.add_option("--verbose", dest="verbose", action="store", type="int", default=0,
                          help="set verbosity level")
        parser.add_option("--noPsycho", dest="usePsycho", action="store_false",
                          default=True,
                          help="disable pyscho compiler")
        (opts, args) = parser.parse_args()
        if len(args) != 2:
            parser.error("wrong number of arguments")
        (self.gbff, self.genePredFile) = args
        self.__dict__.update(opts.__dict__)
        if self.allGenes:
            self.protGenes = self.rnaGenes = self.other = self.immunoglobulins = True
        elif not (self.protGenes or self.rnaGenes or self.otherGenes or self.immunoglobulins):
            self.protGenes = True
        if not self.pseudo:
            self.alive = True
        self.selected = set()
        if self.protGenes:
            self.selected.add(GeneType.protGene)
        if self.rnaGenes:
            self.selected.add(GeneType.rnaGene)
        if self.otherGenes:
            self.selected.add(GeneType.otherGene)
        if self.immunoglobulins:
            self.selected.add(GeneType.immunoglobulin)
        self.active = set()
        if self.live:
            self.active.add(ActiveType.live)
        if self.pseudo:
            self.active.add(ActiveType.pseudo)
        if len(self.active) == 0:
            self.active.add(ActiveType.live)
        if self.verbose >= 1:
            prLine(sys.stderr, "selecting: genes: ", 
                   setOps.setJoin(self.selected), "  ",
                   setOps.setJoin(self.active))

def prWarn(*objs):
    "print warning, a space is added between each arg"
    fh = sys.stderr
    fh.write("Warning:")
    for o in objs:
        fh.write(' ')
        fh.write(str(o))
    fh.write("\n")

class RnaCdsMap(object):
    "associate table of mRNA id to protein id from rna.q file"
    #rna_accession	rna_gi	prot_accession	prot_gi	gene_id	unigene_id	bases	strain	source_db	defline
    def __init__(self,  rnaqFile):
        self.rnaAccMap = dict()
        self.protAccMap = dict()
        for row in TSVReader(rnaqFile):
            self.rnaAccMap[row.rna_accession] = row
            self.protAccMap[row.prot_accession] = row

class TransFeatures(object):
    "object that holds features"

    def __init__(self, gene, transId):
        self.gene = gene
        self.transId = transId  # maybe None
        self.cdsFt = None
        self.cdsCoords = None
        self.mrnaFt = None     # either mrna or *segment features
        self.mrnaCoords = None
        self.miscRnaFt = None
        self.miscRnaCoords = None
        self.exonFts = None
        self.exonCoords = None

    def __str__(self):
        return self.getTransId()

    def getTransId(self):
        "get transcript id, or gene id if transcript id is None"
        if self.transId != None:
            return self.transId
        else:
            return self.gene.geneSym

    def getCdsId(self):
        return (featGetCdsId(self.cdsFt) if self.cdsFt != None else None)

    def addMRna(self, mrnaFt):
        if self.mrnaFt != None:
            raise GbffExcept("transcript already has mRNA: " + self.getTransId())
        self.mrnaFt = mrnaFt

    def getMRnaCoords(self):
        "get mRNA coordinates, or None"
        if (self.mrnaFt != None) and (self.mrnaCoords == None):
            self.mrnaCoords = Coords.fromLocation(self.mrnaFt.location)
        return self.mrnaCoords

    def addMiscRna(self, rnaFt):
        if self.miscRnaFt != None:
            raise GbffExcept("transcript already has misc RNA: " + get.getTransId())
        self.miscRnaFt = rnaFt

    def getMiscRnaCoords(self):
        "get misc RNA coordinates, or None"
        if (self.miscRnaFt != None) and (self.miscRnaCoords == None):
            self.miscRnaCoords = Coords.fromLocation(self.miscRnaFt.location)
        return self.miscRnaCoords

    def addCds(self, cdsFt):
        if self.cdsFt != None:
            raise GbffExcept("transcript already has CDS: " + self.getTransId())
        self.cdsFt = cdsFt

    def getCdsCoords(self):
        "get coordindates defined by CDS feature, or none"
        if (self.cdsFt != None) and (self.cdsCoords == None):
            self.cdsCoords = Coords.fromLocation(self.cdsFt.location)
        return self.cdsCoords

    def addExon(self, exonFt):
        if self.exonFts == None:
            self.exonFts =[]
        self.exonFts.append(exonFt)

    def getExonCoords(self):
        "get exon coordinates, or None"
        if (self.exonFts != None) and (self.exonCoords == None):
            self.exonCoords = Coords()
            for ef in self.exonFts:
                self.exonCoords.extend(Coords.fromLocation(ef.location))
            self.exonCoords.sort()
        return self.exonCoords

    def dump(self):
        prLine(sys.stderr, "\ttranscript: ", self.transId,
               " gene: ", self.gene.geneSym)
        prLine(sys.stderr, "\t   cds: ", self.cdsFt)
        prLine(sys.stderr, "\t  mRNA: ", self.mrnaFt)
        prLine(sys.stderr, "\t  RNA:  ", self.miscRnaFt)
        prLine(sys.stderr, "\t exons: ", self.exonFts)

class GeneFeatures(object):
    """object for a gene and associated transcripts. This reduces gene
    and pseudogene annotations into a common data format.
    If features don't have transcripts ids, they are added to a
    default transcript with a transcript id of None.
    Use GeneID: rather than gene symbol to match features to genes, as they
    are sometimes not consistent.
    """

    def __init__(self, rec, geneFt):
        self.rec = rec
        self.geneSym = featMustGetQual(geneFt, "/gene=")
        self.geneId = featMustGetGeneId(geneFt)
        self.geneFt = geneFt
        self.coords = None
        self.transTbl = dict()
        self.mrnaTrans = []  # ordered list of transcripts from mRNA or *segment features
        self.cdsFts = []   # ordered list of CDS features
        self.miscRnaTrans = [] # list of misc_rna transcripts
        self.geneType = GeneType.unknown
        self.activeType = ActiveType.live
        self.__flagIfPseudoFt(geneFt)
        self.cdsAssocProbs = False  # any problems associating CDS?
        
    def __str__(self):
        return self.geneSym + " (" + self.geneId + ")"

    # FIXME: mostly dup of this code in __procGene
    def prTransCds(self, fh):
        prLine(fh, "gene: ", self)
        prLine(fh, "    mrnaTrans:")
        for trans in self.mrnaTrans:
            prLine(fh, "        ",trans.transId, " ", trans.getMRnaCoords())
        prLine(fh, "    CDS:")
        for cdsFt in self.cdsFts:
            prLine(fh, "        ", featGetCdsId(cdsFt), " ", Coords.fromLocation(cdsFt.location))

    def finish(self, verbose, rnaCdsMap=None):
        "finish construction"
        # set type. since type for non-immunoglobulins pseudogenes is not
        # explicit in annotation, assume they are protein coding
        if self.geneType == GeneType.unknown:
            if len(self.mrnaTrans) > 0:
                 self.geneType = GeneType.protGene
            elif len(self.miscRnaTrans) > 0:
                self.geneType = GeneType.rnaGene
            elif self.activeType == ActiveType.pseudo:
                 self.geneType = GeneType.protGene
            else:
                self.geneType = GeneType.other
        # other tasks
        if len(self.cdsFts) > 0:
                self.__assocCds(verbose, rnaCdsMap)

    def __assocCds(self, verbose, rnaCdsMap):
        "associate a CDS features with mRNA features"
        if len(self.mrnaTrans) != len(self.cdsFts):
            prWarn("Number of CDS features ("+str(len(self.cdsFts))+") doesn't match number of mRNA features ("+str(len(self.mrnaTrans))+") gene:",self)
            self.cdsAssocProbs = True

        for trans in self.mrnaTrans:
            if rnaCdsMap != None:
                if not self.__tblAssocCds(trans, rnaCdsMap):
                    if verbose >= 1:
                        prWarn("can't find CDS for " + trans.getTransId() + " in rna.q file")
                    self.__matchAssocCds(trans)
            else:
                self.__matchAssocCds(trans)

    def __tblAssocCds(self, trans, rnaCdsMap):
        "look up CDS in map"
        rnaCds = rnaCdsMap.rnaAccMap.get(trans.getTransId())
        if rnaCds != None:
            cdsFt = self.__cdsFtById(rnaCds.prot_accession)
            if cdsFt != None:
                trans.addCds(cdsFt)
                return True
        return False

    def __cdsFtById(self, cdsId):
        for cdsFt in self.cdsFts:
            if featGetCdsId(cdsFt) == cdsId:
                return cdsFt
        return None

    def __matchAssocCds(self, trans):
        """ associate CDS with transcripts via longest matched"""
        cdsFt = self.__findLongestCdsMatch(trans)
        if cdsFt == None:
            prWarn("can't match CDS to mRNA for:", trans.transId, "gene:",self)
        else:
            trans.addCds(cdsFt)

    def __findLongestCdsMatch(self, trans):
        "find longest CDS matching a transcript, or None if no match"
        bestSize = 0
        bestCds = None
        for cdsFt in self.cdsFts:
            if GeneFeatures.__cdsMatches(trans, cdsFt):
                cdsCoord = Coords.fromLocation(cdsFt.location)
                sz = cdsCoord.size()
                if sz > bestSize:
                    bestSize = sz
                    bestCds = cdsFt
        return bestCds

    @staticmethod
    def __cdsMatches(trans, cdsFt):
        return trans.getMRnaCoords().isSubrange(Coords.fromLocation(cdsFt.location))
    
    def getCoords(self):
        if self.coords == None:
            self.coords = Coords.fromLocation(self.geneFt.location)
        return self.coords

    def getTrans(self, transId):
        "get transcript by id, create new one if needed.  transId maybe none "
        trans = self.transTbl.get(transId)
        if trans == None:
            trans = TransFeatures(self, transId)
            self.transTbl[transId] = trans
        return trans

    def getTransIds(self):
        """get sorted list of transcript ids.  If no transcripts have been
        created, as would happen if there were no features other than gene,
        a default TransFeatures object is created"""
        if len(self.transTbl) == 0:
            self.getTrans(None)  # create default
        transIds = self.transTbl.keys()
        transIds.sort()
        return transIds

    def __flagIfPseudoFt(self, feat):
        if featHaveQual(feat, "/pseudo"):
            self.activeType = ActiveType.pseudo

    def __getFtTrans(self, feat, required=True):
        if required:
            return self.getTrans(featMustGetQual(feat, "/transcript_id="))
        else:
            return self.getTrans(featGetQual(feat, "/transcript_id="))

    def addMRna(self, mrnaFt):
        trans = self.__getFtTrans(mrnaFt)
        trans.addMRna(mrnaFt)
        self.__flagIfPseudoFt(mrnaFt)

        # keep ordered list for CDS additions
        self.mrnaTrans.append(trans)

    def __getFtIg(self, feat, required=True):
        if required:
            return featMustGetQualByKeys(feat, ("/gene=", "/standard_name="))
        else:
            return featGetQualByKeys(feat, ("/gene=", "/standard_name="))

    def addIg(self, igFt):
        trans = self.getTrans(self.__getFtIg(igFt))
        trans.addMRna(igFt)
        self.__flagIfPseudoFt(igFt)

        # keep ordered list for CDS additions
        self.mrnaTrans.append(trans)

    def addCds(self, cdsFt):
        self.cdsFts.append(cdsFt)
        self.__flagIfPseudoFt(cdsFt)
        
    def addExon(self, exonFt):
        # should always get the default transcript
        trans = self.__getFtTrans(exonFt, required=False)
        assert(trans.transId == None)
        trans.addExon(exonFt)
        self.__flagIfPseudoFt(exonFt)

    def addMiscRna(self, rnaFt):
        trans = self.__getFtTrans(rnaFt)
        trans.addMiscRna(rnaFt)
        self.__flagIfPseudoFt(rnaFt)
        self.miscRnaTrans.append(trans)

    def flagImmunoglobulin(self):
        self.geneType = GeneType.immunoglobulin

    def dump(self):
        prLine(sys.stderr, "gene:", self.geneSym)
        for trans in self.transTbl.itervalues():
            trans.dump()
            
class RecProcessor(object):
    "process a record from the file"

    def __init__(self, rec, opts, rnaCdsMap=None):
        self.rec = rec
        self.opts = opts
        # need to lookup both by id and sym, as sometimes mrna syms don't
        # match gene and exons don't have syms.  Also, sometimes a feature
        # proceeds the gene it references, so do this in two passes.
        self.genes = []
        self.genesById = dict()
        self.genesBySym = dict()
        self.__findGenes(rec)
        self.__findFeats(rec)
        for gene in self.genes:
            self.__finishGene(gene, rnaCdsMap)

    def __finishGene(self, gene, rnaCdsMap):
        gene.finish(self.opts.verbose, rnaCdsMap)
        if (self.opts.verbose >= 2) and gene.cdsAssocProbs:
            gene.prTransCds(sys.stderr)

    def __findGenes(self, rec):
        for feat in rec.features:
            if feat.key == "gene":
                self.__procGeneFt(feat)

    def __procFeat(self, feat):
        if feat.key == "exon":
            self.__procExonFt(feat)
        elif feat.key == "CDS":
            self.__procCdsFt(feat)
        elif feat.key == "mRNA":
            self.__procMRnaFt(feat)
        elif feat.key == "misc_RNA":
            self.__procMiscRnaFt(feat)
        elif feat.key.endswith("_segment") or (feat.key == "C_region"):
            self.__procIGFeat(feat)

    def __findFeats(self, rec):
        for feat in rec.features:
            try:
                self.__procFeat(feat)
            except GbffExcept, ex:
                prWarn(ex)
                if self.opts.verbose >= 2:
                    traceback.print_exc(None, sys.stderr)
                    prLine(sys.stderr)

    def __procGeneFt(self, geneFt):
        geneId = featMustGetGeneId(geneFt)
        if geneId in self.genesById:
            raise GbffExcept("duplicate gene: " + geneId)
        geneSym = featMustGetQual(geneFt, "/gene=")
        gene = GeneFeatures(self.rec, geneFt)
        self.genes.append(gene)
        self.genesById[geneId] = gene
        self.genesBySym[geneSym] = gene
        if self.opts.verbose >= 3:
            prLine(sys.stderr, "parsing gene: ", str(gene))

    def __getGeneObjById(self, feat, required=True):
        if required:
            geneId = featMustGetGeneId(feat)
        else:
            geneId = featGetGeneId(feat)
            if (geneId == None):
                return None
        gene = self.genesById.get(geneId)
        if (gene == None):
            raise GbffExcept("no gene for " + geneId + ", referenced by " + feat.key + " " + feat.location)
        return gene
            
    def __getGeneObjBySym(self, feat, required=True, qualName="/gene="):
        if required:
            self.genesBySym[featMustGetQual(feat, qualName)]
        else:
            geneSym = featGetQual(feat, qualName)
            if (geneSym != None) and (geneSym in self.genesBySym):
                return self.genesBySym[geneSym]
            else:
                return None

    def __procExonFt(self, exonFt):
        gene = self.__getGeneObjBySym(exonFt, required=False)
        if gene != None:
            gene.addExon(exonFt)

    def __procCdsFt(self, cdsFt):
        gene = self.__getGeneObjById(cdsFt)
        gene.addCds(cdsFt)

    def __getRnaGene(self, rnaFt):
        # generally by transcript id, but also try gene
        gene = self.__getGeneObjById(rnaFt, required=False)
        if (gene == None):
            gene = self.__getGeneObjBySym(rnaFt, qualName="/gene=", required=False)
        if (gene == None):
            featRaiseNeedAQual(rnaFt, ("/transcript_id=", "/gene="))
        return gene

    def __procMRnaFt(self, mrnaFt):
        self.__getRnaGene(mrnaFt).addMRna(mrnaFt)

    def __procMiscRnaFt(self, rnaFt):
        self.__getRnaGene(rnaFt).addMiscRna(rnaFt)

    def __procIGFeat(self, igFt):
        # some V_segment have /standard_name= to reference gene sym
        # instead of /gene=, try both
        gene = self.__getGeneObjBySym(igFt, qualName="/gene=", required=False)
        if gene == None:
            gene = self.__getGeneObjBySym(igFt, qualName="/standard_name=", required=False)
        if gene == None:
            featRaiseNeedAQual(igFt, ("/gene=", "/standard_name="))
        gene.addIg(igFt)
        gene.flagImmunoglobulin()

class GenePredBuilder(object):
    "object to build a genePred"
    
    def __init__(self, geneSym, transId, chrom, mkExt):
        self.mkExt = mkExt
        self.gp = GenePred()
        self.gp.name = transId
        self.gp.chrom = chrom
        self.gp.strand = None
        self.gp.txStart = None
        self.gp.txEnd = None
        self.gp.cdsStart = None
        self.gp.cdsEnd = None
        if self.mkExt:
            self.gp.score = 0
            self.gp.name2 = geneSym
            self.gp.cdsStartStat = CdsStat.unknown
            self.gp.cdsEndStat = CdsStat.unknown

    def finish(self):
        if self.gp.cdsStart == None:
            self.gp.cdsStart = self.gp.cdsEnd = self.gp.txEnd
        if self.mkExt:
            self.gp.assignFrames()

    def setCds(self, coord):
        "CDS coords is Coord object"
        assert(len(self.gp.exons) > 0)
        if not ((coord.start < self.gp.txEnd) and (coord.end >self.gp.txStart)):
            prWarn("CDS doesn't overlap transcript:", self.gp.name)
        else:
            self.gp.cdsStart = coord.start
            self.gp.cdsEnd = coord.end
            
    def addExons(self, coords):
        """add exons, given a list of converted coordiante tuples, making adjustments
        to prevent overlapping exons or gaps between tx bounds and exons"""
        prevStart = None
        prevEnd = None
        for e in coords:
            assert(e.start < e.end)
            # adjust tx range to contain exon
            if self.gp.txStart == None:
                self.gp.txStart = e.start
                self.gp.txEnd = e.end
                self.gp.strand = e.strand
            else:
                self.gp.txStart = min(self.gp.txStart, e.start)
                self.gp.txEnd = max(self.gp.txEnd, e.end)
            
            if (prevStart != None) and (e.start <= prevEnd):
                # merge adjacent or overlapping exons
                prevEnd = max(prevEnd, e.end)
            else:
                if prevStart != None:
                    self.gp.addExon(prevStart, prevEnd)
                prevStart = e.start
                prevEnd = e.end

        # last exon
        if prevStart != None:
            self.gp.addExon(prevStart, prevEnd)

class GeneConverter(object):
    """object for pseudo and real gene conversion. Big differences is how we
    get the exon annotations.  For pseudogenes, they come from exon features,
    for genes they come from the mRNA feature"""

    def __init__(self, gene, mkExt):
        self.gene = gene
        self.mkExt = mkExt
        self.outFh = None

    def __convertTrans(self, trans):
        "convert a transcript to a genePred"

        gpb = GenePredBuilder(self.gene.geneSym, trans.getTransId(), self.gene.rec.locus, self.mkExt)

        # get exons, from one of the sources
        if trans.mrnaFt != None:
            gpb.addExons(trans.getMRnaCoords())
        elif trans.miscRnaFt != None:
            gpb.addExons(trans.getMiscRnaCoords())
        elif trans.cdsFt != None:
            gpb.addExons(trans.getCdsCoords())
        elif trans.exonFts != None:
            gpb.addExons(trans.getExonCoords())
        elif trans.cdsFt != None:
            gpb.addExons(trans.getCdsCoords())
        elif trans.gene != None:
            gpb.addExons(trans.gene.getCoords())
        else:
            raise Exception("don't know how to convert: " + str(trans))
        cds = None
        if self.gene.geneType == GeneType.immunoglobulin:
            if len(self.gene.cdsFts) > 0:
                cds = Coords.fromLocation(self.gene.cdsFts[0].location)
        else:
            cds = trans.getCdsCoords()
        if cds != None:
            gpb.setCds(cds.getRange())
        gpb.finish()
        gpb.gp.write(self.outFh)
        
    def convert(self, outFh):
        "convert to a genePred"
        self.outFh = outFh
        # if no transcript info, there is a default transcript
        for transId in self.gene.getTransIds():
            self.__convertTrans(self.gene.transTbl[transId])

class GbffToGenes(object):
    "convert a genbank flat file object to genePreds"
    def __init__(self, opts):
        self.opts = opts
        self.rnaCdsMap = RnaCdsMap(opts.rnaq) if opts.rnaq != None else None

    def __shouldConvert(self, gene):
        return (gene.geneType in self.opts.selected) and (gene.activeType in self.opts.active)
        
    def __procGene(self, gene):
        keep = self.__shouldConvert(gene)
        if self.opts.verbose >= 1:
            prLine(sys.stderr, ("converting" if keep else "skipping"),
                   " gene: ", str(gene), " [", gene.geneType, ", ", gene.activeType, "]")
            for transId in gene.getTransIds():
                trans = gene.transTbl[transId]
                if self.opts.verbose >= 2:
                    prLine(sys.stderr, "    trans: ", trans.getTransId(), " ", 
                           (trans.getMRnaCoords() if trans.mrnaFt != None else trans.getMiscRnaCoords()))
                    prLine(sys.stderr, "    CDS:   ", trans.getCdsId(), " ", trans.getCdsCoords())
                else:
                    prLine(sys.stderr, "    trans: ", trans.getTransId(), " CDS: ", trans.getCdsId())
                           
        if keep:
            cnv = GeneConverter(gene, self.opts.ext)
            cnv.convert(self.outFh)

    def __procRec(self, rec):
        if self.opts.verbose >= 3:
            prLine(sys.stderr, "parsing rec: ", rec.locus)
        recProc = RecProcessor(rec, self.opts, self.rnaCdsMap)
        geneSyms = recProc.genesBySym.keys()
        geneSyms.sort()
        for geneSym in geneSyms:
            self.__procGene(recProc.genesBySym[geneSym])

    def convert(self, genePredFile):
        gbsFh = fileOps.opengz(self.opts.gbff)
        self.outFh = file(genePredFile, "w")
        for rec in Iterator(gbsFh, RecordParser()):
            self.__procRec(rec)
        self.outFh.close()
        gbsFh.close()

opts = CmdOpts()
if opts.usePsycho:
    try:
        import psyco
        psyco.full()
    except ImportError,e:
        pass
gbffConvert = GbffToGenes(opts)
gbffConvert.convert(opts.genePredFile)
