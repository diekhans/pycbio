#!/usr/bin/env python

# FIXME: Required biopython with bug #1758 fixed (genbank parser chokes on /transl_except)

import sys, os, traceback
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.insert(0, myBinDir + "/../lib")

from Bio.GenBank import Iterator, RecordParser, LocationParser
from optparse import OptionParser
from pycbio.sys import fileOps, setOps, typeOps
from pycbio.sys.Pipeline import Pipeline
from pycbio.sys.Enumeration import Enumeration
from pycbio.sys.fileOps import prLine
from pycbio.hgdata.GenePred import GenePred

# FIXME: too many special cases in code, simplify.  Making library
# objects for analyzing genes in annotation

GeneType = Enumeration("GeneType",
                       ("unknown", "protGene", "rnaGene", "immunoglobulin", "other"),
                       bitSetValues=True)
ActiveType = Enumeration("ActiveType",
                         ("unknown", "live", "pseudo"),
                         bitSetValues=True)

class CmdOpts(object):
    usage = """%prog [options] gbff genePred

Parse gene features from genbank flat file records and create a genePred.
Will do pseudogenes or non-pseudogenes.  This is designed to be used on the
NCBI *.gbs.gz files to extract chromosome annotations.  Will read compressed
files.

Retrieve files with:
    wget -nv -r -A 'hs_ref_*.gbs.gz' 'ftp://ftp.ncbi.nih.gov/genomes/H_sapiens/CHR*'
"""
    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        parser.add_option("--protGenes", dest="protGenes", action="store_true",
                          default=False,
                          help="extract protein coding gene annotations, default if no other get options are specified")
        parser.add_option("--rnaGenes", dest="rnaGenes", action="store_true",
                          default=False,
                          help="extract non-protein coding gene annotations")
        parser.add_option("--otherGenes", dest="otherGenes", action="store_true",
                          default=False,
                          help="extract gene annotations where type is undetermined")
        parser.add_option("--immunoglobulins", dest="immunoglobulins", action="store_true",
                          default=False,
                          help="get immunoglobulins genes")
        parser.add_option("--allGenes", dest="allGenes", action="store_true",
                          default=False,
                          help="extra all genes, and immunoglobulins, both pseudo and live")
        parser.add_option("--pseudo", dest="pseudo", action="store_true",
                          default=False,
                          help="extract  pseudogenes, either immunoglobulin or assumed protein coding (since type not annotated)")
        parser.add_option("--live", dest="live", action="store_true",
                          default=False,
                          help="extract  live gene annotations; default if --pseudo is not specified")
        parser.add_option("--verbose", dest="verbose", action="store", type="int", default=0,
                          help="set verbosity level")
        parser.add_option("--noPsycho", dest="usePsycho", action="store_false",
                          default=True,
                          help="disable pyscho compiler")
        (opts, args) = parser.parse_args()
        if len(args) != 2:
            parser.error("wrong number of arguments")
        (self.gbff, self.genePredFile) = args
        self.__dict__.update(opts.__dict__)
        if self.allGenes:
            self.protGenes = self.rnaGenes = self.other = self.immunoglobulins = True
        elif not (self.protGenes or self.rnaGenes or self.otherGenes or self.immunoglobulins):
            self.protGenes = True
        if not self.pseudo:
            self.alive = True
        self.selected = set()
        if self.protGenes:
            self.selected.add(GeneType.protGene)
        if self.rnaGenes:
            self.selected.add(GeneType.rnaGene)
        if self.otherGenes:
            self.selected.add(GeneType.otherGene)
        if self.immunoglobulins:
            self.selected.add(GeneType.immunoglobulin)
        self.active = set()
        if self.live:
            self.active.add(ActiveType.live)
        if self.pseudo:
            self.active.add(ActiveType.pseudo)
        if len(self.active) == 0:
            self.active.add(ActiveType.live)
        if self.verbose > 0:
            prLine(sys.stderr, "selecting: genes: ", 
                   setOps.setJoin(self.selected), "  ",
                   setOps.setJoin(self.active))

class GbffExcept(Exception):
    pass

def prWarn(*objs):
    "print warning, a space is added between each arg"
    fh = sys.stderr
    fh.write("Warning:")
    for o in objs:
        fh.write(' ')
        fh.write(str(o))
    fh.write("\n")

def featFindQual(feat, key):
    "get the specified qualifier, or None"
    for qual in feat.qualifiers:
        if qual.key == key:
            return qual
    return None

def qualTrimVal(qual):
    if qual == None:
        return None
    val = qual.value
    if (val != None) and val.startswith('"') and val.endswith('"'):
        val = val[1:-1]
    return val

def featHaveQual(feat, key):
    "does a feature have a qualifier?"
    return (featFindQual(feat, key) != None)

def featGetQual(feat, key):
    "get the specified qualifier value, or None if not found.  Remove quotes if present"
    qual = featFindQual(feat, key)
    if qual == None:
        return None
    val = qual.value
    if val.startswith('"') and val.endswith('"'):
        val = val[1:-1]
    return val
        
def featMustGetQual(feat, key):
    val = featGetQual(feat, key)
    if val == None:
        raise GbffExcept("qualifier \""+key+"\" not found in feature: " + str(feat))
    return val

def featGetQualByKeys(feat, keys):
    "get feature based on first matching key"
    for key in keys:
        val = featGetQual(feat, key)
        if val != None:
            return val
    return None
    
def featMustGetQualByKeys(feat, keys):
    "get feature based on first matching key, or error"
    val = featGetQualByKeys(feat, keys)
    if val == None:
        featRaiseNeedAQual(feat, keys)
    return val

def featRaiseNeedAQual(feat, keys):
   "raise error about one of the qualifiers not being found"
   raise GbffExcept("didn't find any of these qualifiers: "
                    + ", ".join(keys) + " in feature: " + str(feat))

def featGetGeneId(feat):
    "get a db_ref qualifier for GeneID, or None"

    for qual in feat.qualifiers:
        if (qual.key == "/db_xref=") and qual.value.startswith('"GeneID:'):
            return qualTrimVal(qual)
    return None

def featGetLocusId(feat):
    "get a db_ref qualifier for LocusId, or None"

    for qual in feat.qualifiers:
        if (qual.key == "/db_xref=") and qual.value.startswith('"LocusID:'):
            return qualTrimVal(qual)
    return None

def featMustGetGeneId(feat):
    """get a db_ref qualifier for GeneID.  If it can't be found, but there is
    a LocusID, fake up a GeneID from the LocusID, or error if neither can occur"""
    val = featGetGeneId(feat)
    if val == None:
        val = featGetLocusId(feat)
        if val != None:
            prWarn("/db_xref GeneID not found in feature, using LocusID:", feat)
            val = "GeneID:" + val.split(":")[1]  # fake it
    if val == None:
        raise GbffExcept("/db_xref GeneID not found in feature: " + str(feat))
    return val

def featGetCdsId(feat):
    "get a CDS identifier from qualifier, or None"
    return featGetQualByKeys(feat, ("/protein_id=", "/standard_name="))

class Coord(object):
    "[0..n) coord"
    __slots__ = ("start", "end", "strand")
    def __init__(self, start, end, strand):
        self.start = start
        self.end = end
        self.strand = strand

    def __str__(self):
        return str(self.start) + ".." + str(self.end) + "/"+str(self.strand)

    def size(self):
        return self.end-self.start

    def __cmp__(self, other):
        if not isinstance(other, Coord):
            return -1
        else:
            d = cmp(self.strand, other.strand)
            if d == 0:
                d = cmp(self.start, other.start)
                if d == 0:
                    d = cmp(self.end, other.end)
            return d

    def overlaps(self, other):
        return (self.start < other.end) and (self.end > other.start) and (self.strand == other.strand)

    def contains(self, other):
        return (other.start >= self.start) and (other.end <= self.end) and (self.strand == other.strand)

class Coords(list):
    "List of Coord objects"

    def __init__(self, init=None):
        if init != None:
            list.__init__(self, init)
            assert((len(self)==0) or isinstance(self[0], Coord))
        else:
            list.__init__(self)

    def __str__(self):
        strs = []
        for c in self:
            strs.append(str(c))
        return ",".join(strs)

    def size(self):
        s = 0
        for c in self:
            s += c.size()
        return s

    def getRange(self):
        """get Coord covered by this object, which must be sorted"""
        if len(self) == 0:
            return None
        else:
            return Coord(self[0].start, self[-1].end, self[0].strand)

    def findContained(self, coord):
        "find index of first range containing coord, or None"
        for i in xrange(len(self)):
            if self[i].contains(coord):
                return i
        return None

    def isSubrange(self, other):
        """is other a sub-range of this object. That is, the this
        object is that same as other, with-in the bounds of other."""
        sLen = len(self)
        oLen = len(other)

        # initial block
        oi = 0
        si = self.findContained(other[0])
        if si == None:
            return False
        if (sLen-si) < oLen:
            return False # not enough left to cover

        # internal blocks
        if oLen > 1:
            if other[0].end != self[si].end:
                return False  # initial end mismatch
            si += 1
            oi += 1
            while (si < sLen-1) and (oi < oLen-1):
                if other[oi] != self[si]:
                    return False
                si += 1
                oi += 1
            if other[oi].start != self[si].start:
                return False  # final start mismatch

        # final block
        if other[oi].end > self[si].end:
            return False
        return True

    @staticmethod
    def fromLocation(locSpec):
        """Convert Genbank location spec to Coords"""
        loc = LocationParser.parse(LocationParser.scan(locSpec))
        return Coords(Coords.__cnvLoc(loc))
            
    @staticmethod
    def __getPos(posObj):
        if isinstance(posObj, LocationParser.HighBound) or isinstance(posObj, LocationParser.LowBound):
            val = posObj.base
        else:
            val = posObj.val
        if isinstance(val, LocationParser.Integer):
            val = val.val
        return val

    @staticmethod
    def __cnvAbs(loc, strand):
        if loc.path != None:
            raise GbffExcept("don't know how to handel non-null path in: "+str(loc))
        # dig out start and end based on location class
        if isinstance(loc.local_location, LocationParser.Range):
            start = Coords.__getPos(loc.local_location.low)-1
            end = Coords.__getPos(loc.local_location.high)
        elif isinstance(loc.local_location, LocationParser.Integer):
            # single location
            start = start = loc.local_location.val-1
            end = start+1
        else:
            raise GbffExcept("__cnvAbs can't handle location class: " + str(loc.__class__))
        return Coord(start, end, strand)

    @staticmethod
    def __cnvLoc(loc, strand='+'):
        "convert to a list of Coord objects"
        if isinstance(loc, LocationParser.AbsoluteLocation):
            return [Coords.__cnvAbs(loc, strand)]
        elif isinstance(loc, LocationParser.Function):
            if loc.name == "complement":
                return Coords.__cnvLoc(loc.args, '-')
            if loc.name == "join":
                return Coords.__cnvLoc(loc.args, strand)
        elif isinstance(loc, list):
            coords = []
            for l in loc:
                coords.extend(Coords.__cnvLoc(l, strand))
            return coords
        else:
            raise GbffExcept("don't not how to convert location: " + str(loc))

class TransFeatures(object):
    "object that holds features"

    def __init__(self, gene, transId):
        self.gene = gene
        self.transId = transId  # maybe None
        self.cdsFt = None
        self.cdsCoords = None
        self.mrnaFt = None     # either mrna or *segment features
        self.mrnaCoords = None
        self.miscRnaFt = None
        self.miscRnaCoords = None
        self.exonFts = None
        self.exonCoords = None

    def __str__(self):
        return self.getTransId()

    def getTransId(self):
        "get transcript id, or gene id if transcript id is None"
        if self.transId != None:
            return self.transId
        else:
            return self.gene.geneSym

    def getCdsId(self):
        return (featGetCdsId(self.cdsFt) if self.cdsFt != None else None)

    def addMRna(self, mrnaFt):
        if self.mrnaFt != None:
            raise GbffExcept("transcript already has mRNA: " + self.getTransId())
        self.mrnaFt = mrnaFt

    def getMRnaCoords(self):
        "get mRNA coordinates, or None"
        if (self.mrnaFt != None) and (self.mrnaCoords == None):
            self.mrnaCoords = Coords.fromLocation(self.mrnaFt.location)
        return self.mrnaCoords

    def addMiscRna(self, rnaFt):
        if self.miscRnaFt != None:
            raise GbffExcept("transcript already has misc RNA: " + get.getTransId())
        self.miscRnaFt = rnaFt

    def getMiscRnaCoords(self):
        "get misc RNA coordinates, or None"
        if (self.miscRnaFt != None) and (self.miscRnaCoords == None):
            self.miscRnaCoords = Coords.fromLocation(self.miscRnaFt.location)
        return self.miscRnaCoords

    def addCds(self, cdsFt):
        if self.cdsFt != None:
            raise GbffExcept("transcript already has CDS: " + self.getTransId())
        self.cdsFt = cdsFt

    def getCdsCoords(self):
        "get coordindates defined by CDS feature, or none"
        if (self.cdsFt != None) and (self.cdsCoords == None):
            self.cdsCoords = Coords.fromLocation(self.cdsFt.location)
        return self.cdsCoords

    def addExon(self, exonFt):
        if self.exonFts == None:
            self.exonFts =[]
        self.exonFts.append(exonFt)

    def getExonCoords(self):
        "get exon coordinates, or None"
        if (self.exonFts != None) and (self.exonCoords == None):
            self.exonCoords = Coords()
            for ef in self.exonFts:
                self.exonCoords.extend(Coords.fromLocation(ef.location))
            self.exonCoords.sort()
        return self.exonCoords

    def dump(self):
        prLine(sys.stderr, "\ttranscript: ", self.transId,
               " gene: ", self.gene.geneSym)
        prLine(sys.stderr, "\t   cds: ", self.cdsFt)
        prLine(sys.stderr, "\t  mRNA: ", self.mrnaFt)
        prLine(sys.stderr, "\t  RNA:  ", self.miscRnaFt)
        prLine(sys.stderr, "\t exons: ", self.exonFts)

class GeneFeatures(object):
    """object for a gene and associated transcripts. This reduces gene
    and pseudogene annotations into a common data format.
    If features don't have transcripts ids, they are added to a
    default transcript with a transcript id of None.
    Use GeneID: rather than gene symbol to match features to genes, as they
    are sometimes not consistent.
    """

    def __init__(self, rec, geneFt):
        self.rec = rec
        self.geneSym = featMustGetQual(geneFt, "/gene=")
        self.geneId = featMustGetGeneId(geneFt)
        self.geneFt = geneFt
        self.coords = None
        self.transTbl = dict()
        self.mrnaTrans = []  # ordered list of transcripts from mRNA or *segment features
        self.cdsFts = []   # ordered list of CDS features
        self.miscRnaTrans = [] # list of misc_rna transcripts
        self.geneType = GeneType.unknown
        self.activeType = ActiveType.live
        self.__flagIfPseudoFt(geneFt)
        self.cdsAssocProbs = False  # any problems associating CDS?
        
    def __str__(self):
        return self.geneSym + " (" + self.geneId + ")"

    # FIXME: mostly dup of this code in __procGene
    def prTransCds(self, fh):
        prLine(fh, "gene: ", self)
        prLine(fh, "    mrnaTrans:")
        for trans in self.mrnaTrans:
            prLine(fh, "        ",trans.transId, " ", trans.getMRnaCoords())
        prLine(fh, "    CDS:")
        for cdsFt in self.cdsFts:
            prLine(fh, "        ", featGetCdsId(cdsFt), " ", Coords.fromLocation(cdsFt.location))

    def finish(self):
        "finish construction"
        # set type. since type for non-immunoglobulins pseudogenes is not
        # explicit in annotation, assume they are protein coding
        if self.geneType == GeneType.unknown:
            if len(self.mrnaTrans) > 0:
                 self.geneType = GeneType.protGene
            elif len(self.miscRnaTrans) > 0:
                self.geneType = GeneType.rnaGene
            elif self.activeType == ActiveType.pseudo:
                 self.geneType = GeneType.protGene
            else:
                self.geneType = GeneType.other
        # other tasks
        if len(self.cdsFts) > 0:
            self.__assocCds()

    def __assocCds(self):
        "associate CDS features with mRNA features"
        if len(self.mrnaTrans) != len(self.cdsFts):
            # only a problem if there are some CDSs
            prWarn("Number of CDS features ("+str(len(self.cdsFts))+") doesn't match number of mRNA features ("+str(len(self.mrnaTrans))+") gene:",self)
            self.cdsAssocProbs = True

        self.__matchAssocCds(self.mrnaTrans)

    def __matchAssocCds(self, probTrans):
        """ associate CDS with transcripts via longest matched"""
        for trans in probTrans:
            cdsFt = self.__findLongestCdsMatch(trans)
            if cdsFt == None:
                prWarn("can't match CDS to mRNA for:", trans.transId, "gene:",self)
            else:
                trans.addCds(cdsFt)

    def __findLongestCdsMatch(self, trans):
        "find longest CDS matching a transcript, or None if no match"
        bestSize = 0
        bestCds = None
        for cdsFt in self.cdsFts:
            if GeneFeatures.__cdsMatches(trans, cdsFt):
                cdsCoord = Coords.fromLocation(cdsFt.location)
                sz = cdsCoord.size()
                if sz > bestSize:
                    bestSize = sz
                    bestCds = cdsFt
        return bestCds

    @staticmethod
    def __cdsMatches(trans, cdsFt):
        return trans.getMRnaCoords().isSubrange(Coords.fromLocation(cdsFt.location))
    
    def getCoords(self):
        if self.coords == None:
            self.coords = Coords.fromLocation(self.geneFt.location)
        return self.coords

    def getTrans(self, transId):
        "get transcript by id, create new one if needed.  transId maybe none "
        trans = self.transTbl.get(transId)
        if trans == None:
            trans = TransFeatures(self, transId)
            self.transTbl[transId] = trans
        return trans

    def getTransIds(self):
        """get sorted list of transcript ids.  If no transcripts have been
        created, as would happen if there were no features other than gene,
        a default TransFeatures object is created"""
        if len(self.transTbl) == 0:
            self.getTrans(None)  # create default
        transIds = self.transTbl.keys()
        transIds.sort()
        return transIds

    def __flagIfPseudoFt(self, feat):
        if featHaveQual(feat, "/pseudo"):
            self.activeType = ActiveType.pseudo

    def __getFtTrans(self, feat, required=True):
        if required:
            return self.getTrans(featMustGetQual(feat, "/transcript_id="))
        else:
            return self.getTrans(featGetQual(feat, "/transcript_id="))

    def addMRna(self, mrnaFt):
        trans = self.__getFtTrans(mrnaFt)
        trans.addMRna(mrnaFt)
        self.__flagIfPseudoFt(mrnaFt)

        # keep ordered list for CDS additions
        self.mrnaTrans.append(trans)
        if len(self.miscRnaTrans) > 0:
            raise GbffExcept("both mRNA and misc_rna transcripts for " + str(self))

    def __getFtIg(self, feat, required=True):
        if required:
            return featMustGetQualByKeys(feat, ("/gene=", "/standard_name="))
        else:
            return featGetQualByKeys(feat, ("/gene=", "/standard_name="))

    def addIg(self, igFt):
        trans = self.getTrans(self.__getFtIg(igFt))
        trans.addMRna(igFt)
        self.__flagIfPseudoFt(igFt)

        # keep ordered list for CDS additions
        self.mrnaTrans.append(trans)
        if len(self.miscRnaTrans) > 0:
            raise GbffExcept("both IG and misc_rna transcripts for " + str(self))

    def addCds(self, cdsFt):
        self.cdsFts.append(cdsFt)
        self.__flagIfPseudoFt(cdsFt)
        
    def addExon(self, exonFt):
        # should always get the default transcript
        trans = self.__getFtTrans(exonFt, required=False)
        assert(trans.transId == None)
        trans.addExon(exonFt)
        self.__flagIfPseudoFt(exonFt)

    def addMiscRna(self, rnaFt):
        trans = self.__getFtTrans(rnaFt)
        trans.addMiscRna(rnaFt)
        self.__flagIfPseudoFt(rnaFt)
        self.miscRnaTrans.append(trans)
        if len(self.mrnaTrans) > 0:
            raise GbffExcept("both mRNA and misc_rna transcripts for " +  str(self))

    def flagImmunoglobulin(self):
        self.geneType = GeneType.immunoglobulin

    def dump(self):
        prLine(sys.stderr, "gene:", self.geneSym)
        for trans in self.transTbl.itervalues():
            trans.dump()
            
class RecProcessor(object):
    "process a record from the file"

    def __init__(self, rec, opts):
        self.rec = rec
        self.opts = opts
        # need to lookup both by id and sym, as sometimes mrna syms don't
        # match gene and exons don't have syms.  Also, sometimes a feature
        # proceeds the gene it references, so do this in two passes.
        self.genes = []
        self.genesById = dict()
        self.genesBySym = dict()
        self.__findGenes(rec)
        self.__findFeats(rec)
        for gene in self.genes:
            self.__finishGene(gene)

    def __finishGene(self, gene):
        gene.finish()
        if (self.opts.verbose > 1) and gene.cdsAssocProbs:
            gene.prTransCds(sys.stderr)

    def __findGenes(self, rec):
        for feat in rec.features:
            if feat.key == "gene":
                self.__procGeneFt(feat)

    def __procFeat(self, feat):
        if feat.key == "exon":
            self.__procExonFt(feat)
        elif feat.key == "CDS":
            self.__procCdsFt(feat)
        elif feat.key == "mRNA":
            self.__procMRnaFt(feat)
        elif feat.key == "misc_RNA":
            self.__procMiscRnaFt(feat)
        elif feat.key.endswith("_segment") or (feat.key == "C_region"):
            self.__procIGFeat(feat)

    def __findFeats(self, rec):
        for feat in rec.features:
            try:
                self.__procFeat(feat)
            except GbffExcept, ex:
                prWarn(ex)
                if self.opts.verbose > 1:
                    traceback.print_exc(None, sys.stderr)
                    prLine(sys.stderr)

    def __procGeneFt(self, geneFt):
        geneId = featMustGetGeneId(geneFt)
        if geneId in self.genesById:
            raise GbffExcept("duplicate gene: " + geneId)
        geneSym = featMustGetQual(geneFt, "/gene=")
        gene = GeneFeatures(self.rec, geneFt)
        self.genes.append(gene)
        self.genesById[geneId] = gene
        self.genesBySym[geneSym] = gene
        if self.opts.verbose > 1:
            prLine(sys.stderr, "parsing gene: ", str(gene))

    def __getGeneObjById(self, feat, required=True):
        if required:
            geneId = featMustGetGeneId(feat)
        else:
            geneId = featGetGeneId(feat)
            if (geneId == None):
                return None
        gene = self.genesById.get(geneId)
        if (gene == None):
            raise GbffExcept("no gene for " + geneId + ", referenced by " + feat.key + " " + feat.location)
        return gene
            
    def __getGeneObjBySym(self, feat, required=True, qualName="/gene="):
        if required:
            self.genesBySym[featMustGetQual(feat, qualName)]
        else:
            geneSym = featGetQual(feat, qualName)
            if (geneSym != None) and (geneSym in self.genesBySym):
                return self.genesBySym[geneSym]
            else:
                return None

    def __procExonFt(self, exonFt):
        gene = self.__getGeneObjBySym(exonFt, required=False)
        if gene != None:
            gene.addExon(exonFt)

    def __procCdsFt(self, cdsFt):
        gene = self.__getGeneObjById(cdsFt)
        gene.addCds(cdsFt)

    def __getRnaGene(self, rnaFt):
        # generally by transcript id, but also try gene
        gene = self.__getGeneObjById(rnaFt, required=False)
        if (gene == None):
            gene = self.__getGeneObjBySym(rnaFt, qualName="/gene=", required=False)
        if (gene == None):
            featRaiseNeedAQual(rnaFt, ("/transcript_id=", "/gene="))
        return gene

    def __procMRnaFt(self, mrnaFt):
        self.__getRnaGene(mrnaFt).addMRna(mrnaFt)

    def __procMiscRnaFt(self, rnaFt):
        self.__getRnaGene(rnaFt).addMiscRna(rnaFt)

    def __procIGFeat(self, igFt):
        # some V_segment have /standard_name= to reference gene sym
        # instead of /gene=, try both
        gene = self.__getGeneObjBySym(igFt, qualName="/gene=", required=False)
        if gene == None:
            gene = self.__getGeneObjBySym(igFt, qualName="/standard_name=", required=False)
        if gene == None:
            featRaiseNeedAQual(igFt, ("/gene=", "/standard_name="))
        gene.addIg(igFt)
        gene.flagImmunoglobulin()

class GenePredBuilder(object):
    "object to build a genePred"
    
    def __init__(self, transId, locus):
        self.gp = GenePred()
        self.gp.name = transId
        self.gp.chrom = locus
        self.gp.strand = None
        self.gp.txStart = None
        self.gp.txEnd = None
        self.gp.cdsStart = None
        self.gp.cdsEnd = None

    def finish(self):
        if self.gp.cdsStart == None:
            self.gp.cdsStart = self.gp.cdsEnd = self.gp.txEnd

    def setCds(self, coord):
        "CDS coords is Coord object"
        assert(len(self.gp.exons) > 0)
        if not ((coord.start < self.gp.txEnd) and (coord.end >self.gp.txStart)):
            prWarn("CDS doesn't overlap transcript:", self.gp.name)
        else:
            self.gp.cdsStart = coord.start
            self.gp.cdsEnd = coord.end
            
    def addExons(self, coords):
        """add exons, given a list of converted coordiante tuples, making adjustments
        to prevent overlapping exons or gaps between tx bounds and exons"""
        prevStart = None
        prevEnd = None
        for e in coords:
            assert(e.start < e.end)
            # adjust tx range to contain exon
            if self.gp.txStart == None:
                self.gp.txStart = e.start
                self.gp.txEnd = e.end
                self.gp.strand = e.strand
            else:
                self.gp.txStart = min(self.gp.txStart, e.start)
                self.gp.txEnd = max(self.gp.txEnd, e.end)
            
            if (prevStart != None) and (e.start <= prevEnd):
                # merge adjacent or overlapping exons
                prevEnd = max(prevEnd, e.end)
            else:
                if prevStart != None:
                    self.gp.addExon(prevStart, prevEnd)
                prevStart = e.start
                prevEnd = e.end

        # last exon
        if prevStart != None:
            self.gp.addExon(prevStart, prevEnd)

class GeneConverter(object):
    """object for pseudo and real gene conversion. Big differences is how we
    get the exon annotations.  For pseudogenes, they come from exon features,
    for genes they come from the mRNA feature"""

    def __init__(self, gene):
        self.gene = gene
        self.outFh = None

    def __convertTrans(self, trans):
        "convert a transcript to a genePred"

        gpb = GenePredBuilder(trans.getTransId(), self.gene.rec.locus)

        # get exons, from one of the sources
        if trans.mrnaFt != None:
            gpb.addExons(trans.getMRnaCoords())
        elif trans.exonFts != None:
            gpb.addExons(trans.getExonCoords())
        elif trans.cdsFt != None:
            gpb.addExons(trans.getCdsCoords())
        elif trans.gene != None:
            gpb.addExons(trans.gene.getCoords())
        else:
            raise Exception("don't know how to convert: " + str(trans))
        cds = None
        if self.gene.geneType == GeneType.immunoglobulin:
            if len(self.gene.cdsFts) > 0:
                cds = Coords.fromLocation(self.gene.cdsFts[0].location)
        else:
            cds = trans.getCdsCoords()
        if cds != None:
            gpb.setCds(cds.getRange())
        gpb.finish()
        gpb.gp.write(self.outFh)
        
    def convert(self, outFh):
        "convert to a genePred"
        self.outFh = outFh
        # if no transcript info, there is a default transcript
        for transId in self.gene.getTransIds():
            self.__convertTrans(self.gene.transTbl[transId])

class GbffToGenes(object):
    "convert a genbank flat file object to genePreds"
    def __init__(self, opts):
        self.opts = opts

    def __shouldConvert(self, gene):
        return (gene.geneType in self.opts.selected) and (gene.activeType in self.opts.active)
        
    def __procGene(self, gene):
        keep = self.__shouldConvert(gene)
        if self.opts.verbose > 0:
            prLine(sys.stderr, ("converting" if keep else "skipping"),
                   " gene: ", str(gene), " [", gene.geneType, ", ", gene.activeType, "]")
            for transId in gene.getTransIds():
                trans = gene.transTbl[transId]
                if self.opts.verbose > 1:
                    prLine(sys.stderr, "    trans: ", trans.getTransId(), " ", 
                           (trans.getMRnaCoords() if trans.mrnaFt != None else trans.getMiscRnaCoords()))
                    prLine(sys.stderr, "    CDS:   ", trans.getCdsId(), " ", trans.getCdsCoords())
                else:
                    prLine(sys.stderr, "    trans: ", trans.getTransId(), " CDS: ", trans.getCdsId())
                           
        if keep:
            cnv = GeneConverter(gene)
            cnv.convert(self.outFh)

    def __procRec(self, rec):
        if self.opts.verbose > 1:
            prLine(sys.stderr, "parsing rec: ", rec.locus)
        recProc = RecProcessor(rec, self.opts)
        geneSyms = recProc.genesBySym.keys()
        geneSyms.sort()
        for geneSym in geneSyms:
            self.__procGene(recProc.genesBySym[geneSym])

    def convert(self, genePredFile):
        gbsFh = fileOps.opengz(self.opts.gbff)
        self.outFh = file(genePredFile, "w")
        for rec in Iterator(gbsFh, RecordParser()):
            self.__procRec(rec)
        self.outFh.close()
        gbsFh.close()

def main():
    opts = CmdOpts()
    if opts.usePsycho:
        try:
            import psyco
            psyco.full()
        except ImportError,e:
            pass
    gbffConvert = GbffToGenes(opts)
    gbffConvert.convert(opts.genePredFile)

main()
